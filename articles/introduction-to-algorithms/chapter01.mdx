---
title: 算法导论系列（二）算法在计算中的作用
date: 2022-01-11
cover: https://tva1.sinaimg.cn/large/008i3skNgy1gy8vyutnsuj30ai0dwjru.jpg
---

本书花费一整个章节来阐述算法作为一门学问的应用价值，着重强调算法的实践作用和掌握算法的重要意义。我们计算机科学已经发展成为一门非常庞杂对的学科，有很多重要领域值得研究，计算机硬件的设计和制造、计算机系统的组成原理、操作系统、Machine Learning、计算机网络和软件工程等等领域。为什么在计算机的算力空前提高的今天，算法仍然值得我们投入大量精力去学习和研究？实际上，很多开发应用程序的程序员并不重视算法，最大的原因是在工作中通常不会刻意使用它，也很少需要做深入的性能优化。本章不仅论述了算法的定义和一些关键概念，最重要是的指出了深入学习并掌握算法的重要意义。

# 如何定义算法

书中给出了两个定义，我更倾向于这个定义：

> 算法是用于求解良说明的计算问题的工具。问题陈述了期望的输入/输出关系，算法则描述一个特定的计算过程来实现输入/输出关系。

例如一个排序问题的定义：

> 输入：一个有限排列[a1, a2, ..., an]
> 输出：输入序列的一个排列[_a1, _a2, ..., _an], 满足 \_a1 <= \_a2 <= ... <= \_an

输入称为问题的一个实例，一般来说，问题实例由计算该问题所必须的输入组成。排序问题是计算机科学中最重要的问题之一，因为排序是一个非常常用的基本操作。因此，已经有大量前人研究的各种排序算法提供我们使用。对于给定的问题，哪一个排序算法最合适依赖于很多因素：“问题的规模（排序元素的个数）、这些项已经被稍微排序的程度、关于项的可能限制、计算机的体系结构、以及使用的存储设备的种类”。

如果对任何一个输入实例，算法都可以正确的输出停机，那么就称这个算法是正确的。不正确的算法对某些实例输出并不会正确停机或者输出正确结果。不过需要指出，有时候错误率可控的算法也是有用的，例如我们使用一个机器学习算法去分类、预测某特定量，一个可以在某个概率下给出正确输出的算法是很有用的。但是在一般情况下，即处理可以求得准确解的问题时，我们必然需要采用正确算法。一个精确描述的算法可以是一个计算机程序，可以是自然语言说明，也可以是一个给定的硬件设计。但是这个描述必须详细列出每一步计算的过程。

# 算法可以解决的问题实例

书中举出的例子非常好，每一个例子都是当今及其依赖高效算法并且对人类具有重要影响的领域。第一个例子是人类基因工程，这个问题的目标是从可以获取的所有海量的色号生物特征数据中达成一个期望的输出：获得人类 DNA 中的所有 10 万个基因，确定构成人类 DNA 的 30 亿个化学基对的序列。这个问题的解决需要依靠极其复杂的算法，好的算法可以使得科学家们能够高效使用资源以完成任务，高效的算法能够大幅节省时间和金钱；第二个例子是互联网能够使得全世界的人快速检索大量的信息，典型的是搜索引擎，他的输入实例包括了用户的搜索目标片段和海量的对象信息，需要得出一组匹配用户搜索目标的对象；电子商务，它使得货物与服务能够以二进制信息的方式保存与交换，电子商务中使用的核心技术包括了公钥密码和数字签名，它们以数值算法和数论为基础；最后一个例子是数学规划求解问题，他可以解决所有能够建立合理模型的经济规划和决策问题，这些复杂的问题都可以转化成用线性规划求解的问题。

书中还列举了几个经典的具体问题实例，这里有两个问题需要重点关注：

- 一个图中两个节点的最短路径问题
- 最长公共子序列问题

# 数据结构

数据结构是一种存储和组织数据的方式，旨在便于访问和修改。没有一种单一的数据结构对任何问题都有效，所有最重要的是知道几种数据结构的优势和局限。

数据结构在本书中占据大量的章节，要学习算法并且能够运用常用算法思想解决问题，必须掌握常见的数据结构例如线性表、树和图。

# 高效算法的重要性

即使给定一个问题，并且已经得出了正确算法，在这些正确算法之间也会有效率上的差异存在。而且有时候这种差别比硬件和软件造成的差别重要得多。
书中举出了插入排序和归并排序的算法，我们都知道前者的时间复杂度为 O(n^2)，而后者为 O(nlogn)，在问题规模扩大的时候，两种算法会有巨大的性能差异。
原因是运行算法需要花费的时间随着问题规模的增长速率不同。本书后面会仔细讲到各种排序算法，当然这里我们可以查阅算法的基本过程，给出代码，查看其区别：

```javascript
/**
 * input: [5, 6, 7, 1, 9, 3, 0, 12]
 * step1: [1, 5, 6, 7, 9, 3, 0, 12]
 * step2: [1, 3, 5, 6, 7, 9, 0, 12]
 * step3: [0, 1, 3, 5, 6, 7, 9, 12]
 */

export default function insertSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    const target = arr[i + 1]
    let j = i
    while (arr[j] > target && j >= 0) {
      arr[j + 1] = arr[j]
      j--
    }
    arr[j + 1] = target
  }
}
```
