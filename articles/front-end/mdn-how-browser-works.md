---
title: 渲染页面：浏览器的工作原理
cover: https://tva1.sinaimg.cn/large/e6c9d24egy1gzl96e9bqpj20lc0c0dhk.jpg
date: 2022-02-21
---

<iframe width="560" height="315" src="https://www.youtube.com/embed/0IsQqJ7pwhw" title="浏览器如何工作" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

页面内容快速加载和交互是用户希望得到的 Web 体验，因此开发者应该力争实现这两个目标。**为了解如何提升性能和感知性能，需要大致了解浏览器的工作原理**。

快速响应的网站提供更好的用户体验。用户期待内容快速加载和交互流畅的 Web 体验。**等待资源加载时间和大部分情况下的浏览器单线程执行是影响 Web 性能的两大主要原因**。

等待时间是浏览器快速加载资源的主要瓶颈。为了实现快速加载，开发者的目标就是尽可能快地发送请求的信息，至少是看上去快。网络等待时间是在链路上传送二进制数据到客户端所消耗的链路传输时间。Web 性能优化要做的就是尽可能快地使页面加载完成。

大部分情况下，浏览器是单线程执行的。为了有流畅的交互，开发者的目标是确保网站从流畅的页面滚动到点击响应的交互性能。渲染时间是关键要素，确保主线程可以完成所有给它的任务并且仍然一直可以处理用户交互。通过了解浏览器 JavaScript 运行时单线程的本质和最小化主线程的责任可以优化 Web 性能，来确渲染的流畅和交互响应的及时。

# 导航

导航是加载 Web 页面的第一步。它发生在以下情形：用户在地址栏输入一个 URL、点击一个连接、提交表单或者是其他行为。

Web 性能优化的目标之一就是缩短导航完成所花费的时间，理想情况下，它不会花费太多时间，但是等待时间和带宽会导致其延时。

## DNS 查找

对于一个 Web 页面来说导航的第一步就是定位资源。如果导航到`https://example.com`HTML 页面被定位到`93.184.216.34`的服务器。如果以前没有访问过这个网站，就需要进行 DNS 查找。

<iframe width="560" height="315" src="https://www.youtube.com/embed/mpQZVYPuDGU" title="DNS如何工作" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

浏览器通过服务器名称请求 DNS 进行查找，最终返回一个 IP 地址，第一次初始化请求之后，这个 IP 地址可能会被缓存一段时间，这样可以通过缓存里面检索 IP 地址而不再是通过域名服务器进行查找来加速后续的请求。

通过主机名加载一个页面通常仅需要 DNS 查找一次。但是 DNS 需要对页面加载的各种资源指向的主机名进行查找。如果 fonts、images、scripts 等都有不同的主机名，那么 DNS 需要对每一个进行查找。

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzl9rtzsqsj21900hmgo9.jpg)

DNS 查找对于性能来说是一个问题，特别是对于移动网络。当一个用户用的是移动网络，每一个 DNS 查询都必须从手机发送到信号塔，然后到达一个认证 DNS 服务器。这个过程又可能要带来一个大的延迟。

## TCP 握手

一旦获取到服务器的 IP 地址，浏览器就会通过 TCP“三次握手”和服务器建立连接。这个机制是用来让两端尝试通过 HTTP 或 HTTPS 这样的应用层协议通信之前，先建立 TCP 连接。通过上层协议也可以协商 TCP 套接字连接时采用的一些参数。

TCP 的“三次握手”（“SYN-(SYN+ACK)-ACK”）。这意味着在 HTTP 报文传输发生之前还需要花费 3 次消息传送的时间。

<iframe width="560" height="315" src="https://www.youtube.com/embed/F27PLin3TV0" title="建立TCP连接" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## TLS 协商

为了在 HTTPS 上建立安全连接，另一种握手是必须的。准确来说是 TLS 协商，决定了加密通信要使用的密钥。在发送真正的请求内容之前还需要三次往返服务器。

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzla3cyqiej21c40mytcl.jpg)

虽然建立 TLS 增加了页面等待时间，对于建立一个安全的连接来说，以增加等待时间为代价是值得的，因为在浏览器和 Web 服务器之间的数据传输不能被第三方解密。

浏览器需要与 DNS 服务器之间进行两次通信，在与 Web 服务器之间进行 8 次通信之后才能发出第一个 HTTP 请求报文。

一旦建立了到 Web 服务器的连接，浏览器就代表用户发送一个初始的 HTTP GET 请求，对于网站来说，这个请求通常是一个 HTML 资源。一旦服务器收到请求，它将使用相关的响应头和 HTML 内容进行回复。

## TCP 慢启动/14Kb 规则

第一个响应包是 14Kb 大小。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到到达网络的最大带宽。

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzlau7g5aej21oy0nsq79.jpg)

在“TCP 慢启动”中，收到初始包之后，服务器的下一个包的大小将加倍到 28kb，后续的依次是前面的 2 倍直到达到设定的阈值或者拥塞。TCP 慢开始逐渐建立适合网络能力的传输速度，以避免拥塞。

> 实际上，TCP 连接允许关闭慢启动，很多服务器也是这么做的。

## 拥塞控制

当服务器用 TCP 包来发送数据时，客户端通过返回确认帧来确认传输。由于硬件和网络条件，连接的容量是有限的。如果服务器太快地发送太多的包，他们可能被丢弃。意味着，将不会有确认帧的返回。服务器把它们当作确认帧丢失。拥塞控制算法使用这个发送包和确认帧来确定发送速率。

# 解析

<iframe width="560" height="315" src="https://www.youtube.com/embed/SmE4OwHztCc" title="浏览器如何渲染网页" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

一旦浏览器收到收据的第一块，就可以开始解析收到的信息。**解析**是浏览器将通过网络接口接收到的 HTML 文档转换为 DOM 和 CSSOM 的步骤，之后才可以进入**渲染**阶段，通过渲染器将 DOM 和 CSSOM 在屏幕上绘制成页面。

可以通过 JavaScript 中的各种 API 进行 DOM 操作。

即使请求页面的 HTML 文档大小大约 14Kb，浏览器也将开始解析并且尝试根据已有的数据进行渲染。这个就是为什么在前 14Kb 中包含浏览器开始渲染页面所需的所有内容，或者至少页面模版（第一次渲染所需要的 CSS 和 HTML）对于 Web 性能优化来说是重要的。但是在渲染到屏幕上之前，HTML、CSS、JavaScript 必须被解析完成。

## 构建 DOM 树

第一步就是处理 HTML 标记并且构造 DOM 树。HTML 解析涉及到 tokenization 和树的构造。HTML 标记包括了开始和结束标记、属性名/值。如果文档格式良好，解析它是一个简单而快速的过程。解析器将标记化的输入解析道文档中构建文档树。DOM 树描述了文档的内容。`<html>`元素是第一个标签也是文档树的根节点。树反映了不同标记之间的关系和层次结构。嵌套在其他标记中的标记是子节点。DOM 节点的数量越多，构建 DOM 树所需的时间越长。

当解析器发现非阻塞资源时，例如一张图片，浏览器会请求这些资源并且继续解析。当需要一个 CSS 文件时，解析器也可以继续进行，但是对于`<script>`标签（没有`async`或者`defer`属性）会阻塞渲染并且停止 HTML 的解析。尽管浏览器的预加载扫描器加速了这个过程，但是过多的脚本仍然是一个重要的瓶颈。

## 预加载扫描器

浏览器在构建 DOM 树时，这个过程占用了主线程，当这种情况发生时，预加载扫描器将解析可用的内容并请求高优先级资源，例如 CSS、JavaScript 和 Web 字体。多亏了预加载扫描器，我们不必等到解析器找到对外部资源的引用来请求它。它将在后台检索资源，以便在主 HTML 解析器到达请求的资源时，它们可能已经在运行，或者已经被下载。预加载扫描器提供的优化减少了阻塞。

为了确保脚本不会阻塞进程，当 JavaScript 解析和执行顺序不重要时可以添加`async`或者`defer`属性。

等待获取 CSS 不会阻塞 HTML 的解析或者下载，但是的确阻塞 JavaScript，因为 JavaScript 经常用于查询元素的 CSS 属性。

## 构建 CSSOM 树

第二步是处理 CSS 并构建 CSSOM 树。CSS 对象模型和 DOM 是相似的。DOM 和 CSSOM 是两棵树。它们是独立的数据结构。浏览器将 CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。

和 HTML 一样，浏览器需要将接收到的 CSS 规则转换为可以使用的内容。因此，它重复了 HTML 到对象的过程，只不过换成了 CSS。

CSSOM 树包括来自用户代理样式表的样式。浏览器从适用于节点的最通用规则开始，并通过应用更具体的规则递归地优化计算的样式。换句话说，它级联属性值。

构建 CSSOM**非常非常快**。在 Web 性能优化方面，它是可以轻易实现的，因为创建 CSSOM 的总时间通常小于一次 DNS 查找所需的时间。

## JavaScript 编译

当 CSS 被解析并创建 CSSOM 时，其他资源，包括 JavaScript 文件正在下载（多亏了预加载扫描器）。JavaScript 被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎将抽象语法树传递到解释器中，输出在主线程上执行的字节码。这就是 JavaScript 编译过程。

## 构建辅助功能树

浏览器还构建辅助设备用于分析和解释内容的辅助功能树。可访问性对象模型（AOM）类似于 DOM 的语义版本。当 DOM 更新时，浏览器会更新辅助功能树。辅助技术本身无法修改可访问性树。

在构建 AOM 之前，屏幕阅读器无法访问内容。

# 渲染

渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。在解析步骤中插棍见的 CSSOM 树和 DOM 树组合成一个 Render 树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是 CPU 上绘制屏幕的一部分来提高性能，从而释放主线程。

<iframe width="560" height="315" src="https://www.youtube.com/embed/lvb06W_VKVE" title="渲染树" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Style 样式计算

第三步是将 DOM 和 CSSOM 组合成一个 Render 树，计算样式树或渲染树。从 DOM 树的根开始构建，遍历每个可见节点。

像`<head>`和它的子节点以及任何具有`display: none`样式的节点，这些标签将不会显示。也就是它们不出现在 Render 树上。具有`visibility: hidden`的节点会出现在 Render 树上，因为它们会占用空间。

每个可见节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树的每个可见节点，并且根据 CSS 级联确定每个节点的计算样式。

## Layout 布局

第四步是在渲染树上运行布局计算每个节点的几何体。布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。回流是对页面的任何部分或者整个文档的任何后续大小和位置决定。

构建渲染树后，开始布局。渲染树标识显示哪些几点（即使不可见）及其计算样式，但不标识每个节点的尺寸或位置。为了确定每个对象的确切大小和位置，浏览器从渲染树的根开始遍历它。

在网页上，大多数东西都是一个盒子。不同的设备和不同的桌面意味着无限数量的不同的视区大小。在此阶段，考虑到视区大小，浏览器将确定屏幕上所有不同框的尺寸。以视区的大小为基础，布局通常从 body 开始，用每个元素的盒子模型属性排列所有的 body 后代元素的尺寸，为不知道其尺寸的替换元素（例如图像）提供占位符空间。

第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为**回流**。假设初始布局发生在返回图像之前，由于没有声明图像的大小，因此一旦知道图像大小就会发生回流。

## Paint 绘制

最后一步是将各个节点绘制到屏幕上，第一次出现的节点称为“first meaningful paint”。在绘制或光栅化阶段，浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素。绘画包括将元素的每个元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影和替换的元素（如按钮和图像）。浏览器需要非常快地完成这项工作。

为了确保平滑滚动和动画，占据主线程的所有内容，包括计算样式，以及回流和绘制，必须让浏览器在 16.67 毫秒内完成。例如 2048 x 1536 分辨率的 iPad，有超过 314.5 万像素会被绘制到屏幕上。那是很多像素需要快速绘制。为了确保**重绘**的速度比初始绘制的速度更快，屏幕上的绘图通常会被分解成数层。如果发生这种情况，则需要进行合成。

绘制可以将布局树中的元素分解成多个层。将内容提升到 GPU 的上层（而不是 CPU 的主线程）可以提高绘制和重新绘制性能。有一些特定的属性和元素可以实例化一个层，包括`<video>`和`<canvas>`，任何 CSS 属性为`opacity`、3D 转换的元素，还有一些其他元素。这些节点将与子节点一起绘制到它们自己的层上，除非子节点由于上述一个（或者多个）原因需要自己的层。

层确实可以提高性能，但是它以内存管理为代价，因此不应该作为 Web 性能策略的一部分过度使用。

## Compositing

当文档的各个部分以不同的层绘制、相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。

当页面继续加载资源时，可能会发**回流**，回流会触发**重绘**和**重新组合**。如果我们定义了图像的大小，就不需要重新绘制，只需要重新绘制需要重新绘制的层，并且在必要的时候进行合成。但是如果没有定义图片元素大小，那么从服务器获取图像后，渲染过程将返回到**布局**步骤（回流）并从此重新开始。

# 交互

一旦主线程绘制页面完成，可能会认为页面已经“准备好了”，但是事实并非如此。如果加载包含 JavaScript（并且延迟到`onload`时间触发后执行），则主线程可能很忙，无法用于滚动、触摸和其他交互。

“Time to Interactive”是测量从第一个请求导致 DNS 查找和 SSL 连接到页面可交互时所用的时间——可交互是”First Contentful Paint”之后的时间点，页面 50ms 内响应用户的交互。如果主线程正在解析、编译和执行 JavaScript，则它不可用，因此无法及时（小于 50ms）响应用户交互。
