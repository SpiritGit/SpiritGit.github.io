---
title: 红宝书系列（十一）期约与异步函数
date: 2022-02-09
cover: https://tva1.sinaimg.cn/large/e6c9d24egy1h0xw8fi1wfj20sg0lcdh0.jpg
---

ES6 及之后发布的版本逐步加大了对异步编程机制的支持，提供了令人眼前一亮的特性。ES6 新增了正式的`Promise`（期约）引用类型，支持优雅定义和组织异步逻辑。接下来几个版本增加了使用`async`和`await`关键字定义异步函数的机制。

# 异步编程

同步行为和异步行为的对立统一是计算机科学的一个基本概念。JavaScript 运行时才用了单线程事件循环模型，因此同步操作和异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。

重要的是，异步操作并不一定计算量大或者要等待很久。只要不想为了等待某个异步操作而阻塞线程执行，那么任何时候都可以用。

## 同步与异步

**同步行为**对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出栈的顺序来执行，每条指令执行后也能立即获得存储在系统本地的信息（如寄存器或内存中的数据）。这样的执行流程容易分析程序在执行到代码任意位置时的状态（例如变量的值）。

在同步执行的过程中，程序执行的每一步的状态都是可以推断的。因为后面的指令总是在前面的指令完成后才会执行。

```javascript
let x = 3
x += 4
```

这两行 JavaScript 代码对应的机器指令可以想象。首先，操作系统会在栈内存上分配一个存储浮点数的空间，然后针对这个值做一次浮点运算，然后将结果写回之前分配的内存中。所有这些指令都是在单个线程中按序执行的，在低级指令的层面，有充足的工具可以确定系统状态。

相对地，**异步行为**类似系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作是对计算资源的极大浪费（同步操作则必须等待）。如果代码需要访问一些高延迟的资源，例如向远程服务器发送请求并等待响应，那么就会出现长时间等待。

```javascript
let x = 3
setTimeout(() => (x += 4), 1000)
```

在以上类似在定时回调中进行数学计算的简单异步操作中，执行线程不知道变量`x`的值何时改变，因为这取决于回调何时从消息队列中出列并执行。

异步代码不容易推断。虽然这个例子很简单，但是第二个指令块是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候触发这个中断，对 JavaScript 运行时来说是无法知道的（尽管可以保证发生在当前线程的同步代码执行之后，否则回调没有机会出列执行）。无论如何，在排定回调以后基本没有办法知道系统状态何时变化。

为了让后续代码能够使用`x`，异步执行的函数需要在更新`x`的值以后通知其他代码。如果程序不需要这个值，那么就只管继续执行，不必等待这个结果了。设计一个能够知道`x`什么时候可以读取的系统是非常难的，`JavaScript`在实现这样一个系统的过程中也经历了几次迭代。

## 早期异步编程模式

虽然异步行为是 JavaScript 的基础，但是早期的实现并不理想。早期 JavaScript 只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。

假设一个异步操作回返回一个有用的值，有什么好办法来将这个值传给需要它的地方？广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码。

```javascript
function double(value, callback) {
  setTimeout(() => {
    callback(value * 2)
  }, 1000)
}

double(3, x => console.log(`recieve ${x}`))
```

这里的`setTimeout`调用告诉 JavaScript 运行时在`1000`毫秒之后将一个函数推到消息队列上。这个函数会由运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然是可用的。

异步操作并不总是成功的，因此自然需要在模型中使用失败回调。

```javascript
function double(value, success, failure) {
  setTimeout(() => {
    try {
      if (typeof value !== 'number') {
        throw 'Must Provide number'
      }
      success(2 * value)
    } catch (e) {
      failure(e)
    }
  }, 1000)
}

const successCallback = x => console.log(x)
const failureCallback = e => console.error(e)

double(3, successCallback, failureCallback)
double('a', successCallback, failureCallback)
```

如果异步返回值又依赖另一个异步返回值，那么回调的情况还会进一步复杂。在实际代码中，这就要求嵌套回调。随着代码变得更加复杂，回调策略是不具有扩展性的，“回调地狱”这个称呼意味着嵌套回调的代码维护起来就是噩梦。

# 期约

**期约`Promise`是对尚不存在结果的一个替身**。早在 1976 年的论文中就有学者提出`Promise`的概念。直到 1988 年，这个概念才真正确立了下来。这个概念描述了一种异步程序执行的机制。

## Promises/A+规范

早期的期约机制在 jQuery 和 Dojo 中都出现过（Deferred API）。到了 2010 年，CommonJS 项目实现的 Promise/A 规范日益流行起来。很多第三方的 JavaScript 期约库得到了社区认可，但是实现多少有些不同。为了弥合现有实现之间的差异，2012 年 Promises/A+组织 fork 了 CommonJS 的 Promise/A 建议，制定了 Promises/A+规范。这个规范最终成为了 ES6 规范实现的范本。

ES6 增加了对 Promises/A+规范的完善支持，即`Promise`类型。一经推出后，`Promise`就大受欢迎成为了主导的异步编程机制。所有的现代浏览器都支持 ES6 期约，很多其他浏览器 API 例如`fetch`和 Battery Status API 也以期约为基础。

## 期约基础

ES6 新增的引用类型期约`Promise`可以通过`new`操作符实例化。创建新期约时需要传入执行器函数作为参数。

```javascript
const p = new Promise((resolve, reject) => {
  try {
    setTimeout(() => resolve('OK'), 1000)
  } catch (e) {
    reject(e)
  }
})
console.log(p) // Promise { <pending> }

setTimeout(() => {
  console.log(p) // Promise { 'OK' }
}, 1001)
```

期约采用了有限状态机模型。一个期约实例传给`console.log`时，控制台会输出期约的状态。一个期约对象可以处于三种状态之一：

- 待定（pending）
- 兑现（fulfilled，有时候称为“解决”，resolved)
- 拒绝（rejected）

**待定**（pending）是期约最初始的状态。在待定状态下，期约可以进一步**落定**（settled）为代表成功的**兑现**状态或者代表失败的**拒绝**状态。无论期约落定为哪种状态都是不可逆的。只要从待定转换为兑现或者拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约最终解决还是拒绝，甚至一直待定，都应该具有恰当的行为。

重要的是，期约的状态是私有的，不能通过 JavaScript 以任何方式来检测到。这主要是为了避免根据读取到期约的状态来以同步的方式处理期约对象。这个状态也无法被 JavaScript 以任何方式从对象外部修改。**期约故意将异步行为封装起来，从而隔离外部的同步代码**。

期约主要有两大用途。首先是抽象表示一个异步操作。期约的状态代表期约是否完成。“待定”表示尚未开始或者正在执行中。“兑现”表示异步任务已经成功完成，而“拒绝”则表示没有成功完成。

某些情况下，这个状态机就是期约可以提供的最有用的信息。知道一段异步代码已经完成，对于其他代码而言已经足够了。例如假设期约要向服务器发送一个 HTTP 请求。请求返回 200 ～ 299 内的状态码就足以让期约的状态变为“兑现”。类似如果不在这个范围，期约状态切换为“拒绝”。

在另一些情况下，期约封装的异步操作会实际生成某个值，而程序期待状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝理由。例如假设期约向服务器发送一个 HTTP 请求并且预定会返回一个 JSON。如果请求返回范围在 200 ～ 299 的状态码，则足以让期约状态变为兑现。此时期约内部就可以收到一个 JSON 字符串。类似如果请求返回的状态码不在 200 ～ 299 这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个`Error`对象，包含着 HTTP 状态码及相关错误消息。

为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部**值**（value）。类似地，每个期约只要切换状态为拒绝，就会有一个私有的内部**理由**（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，并且默认值为`undefined`。在期约到达到某个落定状态时执行的异步代码始终会收到这个值或理由。

由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为`resolve()`和`reject()`。调用`resolve()`会把状态切换为兑现，调用`reject()`会把状态切换为拒绝。另外，调用`reject()`也会抛出错误。

期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用`Promise.resolve()`静态方法可以实例化一个解决的期约。

```javascript
// 下面两个期约实例实际上是一样的
const p1 = new Promise((resolve, reject) => resolve())
const p2 = Promise.resolve()
```

Promise 的设计很大程度上会导致一种全新的计算模式。下面的例子完美展示了这点：

```javascript
try {
  throw new Error('foo')
} catch (e) {
  console.log(e.message) // 正确捕获异常
}

try {
  Promise.reject('some error')
} catch (e) {
  console.log(e.message) // 并不能在这里捕获到异常，原因是只能捕获到同步代码中抛出的异常
}

Promise.reject('some error').catch(e => console.log(e)) // 正确捕获异常
```

可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是**异步**执行模式的媒介。这个例子中，拒绝期约的错误没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此`try/catch`块并不能捕获错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构，即期约的方法。

## 期约的实例方法

期约实例的方法是连通外部代码和内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。

在 ECMAScript 暴露的异步结构中，任何对象都有一个`then`方法。这个方法被认为实现了`Thenable`接口。

```javascript
class MyThenable {
  then() {}
}
```

ECMAScript 的`Promise`类型实现了`Thenable`接口。这个简化的接口跟 TypeScript 或者其他报中的接口或类型定义不同，他们都设定了`Thenable`接口更具体的形式。

`Promise.prototype.then()`是为期约实例添加处理程序的主要方法。这个`then()`方法接收最多的两个参数：`onResolved`处理程序和`onRejected`处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。

因为期约只能转换为最终状态一次，因此这两个操作必然互斥。`Promise.prototype.catch()`方法用于给期约添加拒绝处理程序，方法只接受一个参数`onRejected`处理程序。这个方法实际上就是一个语法糖，调用它就相当于调用`Promise.prototype.then(null, onRejected)`。

`Promise.prototype.finally()`方法用于给期约添加`onFinally`处理程序，这个处理程序在期约转换为解决或拒绝状态时**都会执行**。这个方法可以避免在`onResolved`和`onRejected`处理程序中出现冗余代码。但是`onFinally`处理程序没有办法知道期约状态是否拒绝，主要用来添加清理代码。

当期约进入落定状态时，与该状态相关的处理程序仅仅会被**排期**，而非立即执行。跟在添加这个处理程序的代码后面的同步代码一定会在处理程序之前执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”特性。

## 期约连锁与期约合成

多个期约组合在一起可构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。

### 期约连锁

把期约逐个串联起来时一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方法（`then()`、`catch()`和`finally()`）都返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简 洁地将异步任务串行化，解决之前依赖回调的难题。所以期约可以很好解决回调地狱的问题！

### 期约合成

`Promise`类提供了两个将多个期约实例合成一个期约的静态方法：`Promise.all()`和`Promise.race()`。而合成后期约的行为取决于内部期约的行为。

`Promise.all()`静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约。合成的期约只会在每个包含的期约都解决之后才解决。如果有一个包含的期约待定，那么合成的期约也会待定；如果一个包含的期约拒绝，那么合成的期约也会拒绝。如果所有的期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组。

**ES6 不支持取消期约和进度通知**，一个主要原因就是这样会导致期约连锁和期约合成 过度复杂化。

# 异步函数

期约的主要功能是为异步代码提供了清晰的抽象。可以用期约表示异步执行的代码块，也可以用期约表示异步计算的值。在需要串行异步代码时，期约的价值最为突出。作为可塑性极强的一种结构，期约可以被序列化、连锁使用、复合、扩展和重组。

异步函数是将期约应用于 JavaScript 函数的结果。异步函数可以暂停执行，而不阻塞主线程。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。异步函 数可以说是现代 JavaScript 工具箱中最重要的工具之一。
